---
title: "iMKT Pipeline"
output: 
  pdf_document:
    highlight: monochrome
    latex_engine: xelatex
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{iMKT Pipeline}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	fig.align = "center",
	fig.height = 7,
	fig.width = 7,
	collapse = TRUE,
	comment = "#>"
)
```

Brief intro about why we developed the package. The importance of detecting adaptation, and the many MKT derived methodologies. Take from paper.

Explain also that iMKT faces this variety of methodologies, and is able to compute several tests in order to detect adaptation in diverse situations. 

In addition, it also provides a way to quantify negative selection, which may overlap with signals of positive selection in the target region, causing the failing of certain MK tests.

&nbsp;

## Loading the package and checking test data

First of all, install (if this is not done yet) and load the package. Notice that iMKT package includes two sample dataframes named mydafdata and mydivergencedata which are the ones used in this tutorial. This makes easier to replicate the vignettes in order to better understand all the package functionalities. 

&nbsp;

```{r load package and see sample data, echo=T}
## Load package
# install.packages("devtools")
# devtools::install_github("sergihervas/iMKT")
library(iMKT)

## Sample daf data
head(mydafdata)

## Sample divergence data
mydivergencedata
```

&nbsp;

The iMKT package includes several funcions, classified as follows:

\begin{itemize}
\item
  MKT derived methodologies calculation
  \begin{itemize}
  \item
    standard(): Standard MKT 
  \item
    FWW(): FWW correction 
  \item
    DGRP(): DGRP correction   
  \item
    asymptoticMK(): Asymptotic MKT 
  \item
    iMK(): integrative MKT  
  \item
    completeMKT(): perform all previous tests
  \end{itemize}

\item
  iMK using PopFly and PopHuman data
  \begin{itemize}
  \item
    loadPopFly(): load PopFlyData
  \item
    loadPopHuman(): load PopHumanData
  \item
    PopFlyAnalisys(): perform any test using PopFlyData
  \item
    PopHumanAnalysis(): perform any test using PopHumanData
  \end{itemize}

\item
  Miscelanious
  \begin{itemize}
  \item
    multipleDatasets(): analyze all datasets in your working directory
  \item
    checkInput(): check data before performing analyses
  \item
    themePublication(): output plots and tables styling
  \end{itemize}
\end{itemize}

&nbsp;

Each function has an associated help page with its description, details about its parameters, usage, examples and so on. Rembember you can access it writting ?? and the function name (or ??library::function) in your console (*example*: ??iMKT::standard).

This vignette focuses on the first category of functions: "MKT derived methodologies calculation". Specifically, it contains examples of each function using the sample data described above. However, the last section of the document provides an example on how to use the *multipleDatasets()* function. For details about functions from "iMKT using PopFly and PopHuman data" category check the corresponding vignette.

&nbsp;

## Performing MKT derived methodologies calculation

The diverse functions from this category have two common input parameters which are required to perform the corresponding test:

\begin{itemize}
\item
  daf: data frame containing DAF, Pi and P0 values (mydafdata)
\item
  divergence: data frame containing divergent and analyzed sites for selected (i) and neutral (0) classes (mydivergencedata)
\end{itemize}

&nbsp;


### Standard MKT

Brief theoretical description about MKT

The **standard()** function uses daf and divergence input parameters and returns as output a list containing:

\begin{itemize}
\item
  alpha symbol: estimate of alpha using the standard MKT
\item
  Fisher exact test P-value: p-value obtained using the Fisher exact test on a 2x2 contingency table (MKT table)
\item
  MKT table: table containing the number of polymorphic and divergent sites for neutral and selected classes.
\item
  Divergence metrics: table containing estimates of Ka, Ks, omega, omegaA, omegaD.
\end{itemize}

&nbsp;

```{r Standard MKT, echo=TRUE}
standard(daf=mydafdata, divergence=mydivergencedata)
```

&nbsp;

### FWW correction

Alpha estimates can be biased by the segregation of slighlty deleterious substitutions. One method to partially controlled its effects is to remove low frequency polymorphisms from the analysis, as proposed by Fay et al. (2001).

The **FWW()** function uses daf and divergence input parameters, along with a default list of cutoffs (0, 0.05, 0.1) and returns as output a list containing:

\begin{itemize}
\item
  Results: alpha estimates (and their associated Fisher exact test P-value) for each cutoff.
\item
  Divergence metrics: global metrics (Ka, Ks, omega) and estimates by cutoff (omegaA, omegaD)
\item
  MKT tables: tables containing the number of polymorphic and divergent sites for neutral and selected classes for each cutoff.
\end{itemize}

&nbsp;

```{r FWW, echo=TRUE}
FWW(daf=mydafdata, divergence=mydivergencedata)
```

&nbsp;

By default the argument **list_cutoff** uses a list of cutoffs with the following values: 0, 0.05, 0.1. Moreover, the function has an optional argument, **plot**, which is set to **FALSE** by default. This parameters can be customized, like in the following example, where we use a list of 4 cutoffs (0.05, 0.15, 0.25, 0.35) and set the plot argument to **TRUE**.

The output in this case contains a **Graph** which shows the adaptation value (alpha) obtained using each cutoff.

&nbsp;

```{r FWW plot, echo=TRUE, fig.width=6, fig.height=4}
FWW(daf=mydafdata, divergence=mydivergencedata, list_cutoff=c(0.05, 0.15,0.25,0.35), plot=TRUE)
```

&nbsp;

### DGRP correction

To take adaptive and slightly deleterious mutation mutually into account, Pn , the count of segregating sites in the non-synonymous class, should be separated into the number of neutral variants and the number of weakly deleterious variants, Pn = Pn(neutral) + Pn(weakly del.). If both numbers are estimated, adaptive and weakly deleterious selection can be evaluated independently. 

Consider a pair of 2×2 contingency tables. The first one corresponds to the standard MKT table with the theoretical counts of segregating sites and divergent sites for each cell. 

The second table contains the count of Pn and Ps for two-frequency categories: below and over a threshold cutoff. 

Add brief explanation about 2nd table!
<!-- The estimate of the fraction of sites segregating neutrally within the DAF (derived allele frequency) < cutoff (f neutral DAF < cutoff) is f neutral(DAF<cutoff) = Ps(DAF<cutoff) / Ps . The expected number of segregating sites in the non-synonymous class which are neutral within the DAF < cutoff is P(neutral DAF<cutoff) = Pn × f neutral(DAF<cutoff). The expected number of neutral segregating sites in the non-synonymous class is Pn(neutral) = P(neutral DAF<cutoff) + Pn(DAF>cutoff).  -->

To estimate alpha from the standard MKT table correcting by the segregation of weakly deleterious variants, we have to substitute the Pn by the expected number of neutral segregating sites, Pn(neutral). The correct estimate of alpha is then alpha = 1 - (Pn (neutral)/Ps)(Ds/Dn).

The **DGRP()** function behaves similar to the **FWW()** function. It takes the same input argument and returns the same output but containing also estimates on the **fractions of negative selection** (d: strongly deleterious, f: neutral and b: weakly deleterious).

&nbsp;

```{r DGRP, echo=TRUE}
DGRP(daf=mydafdata, divergence=mydivergencedata)
```

&nbsp;

Again, by default the argument **list_cutoff** uses a list of cutoffs with the following values: 0, 0.05, 0.1, and the argument **plot** is set to **FALSE**. This parameters can be customized, like in the following example, where we use a list of 4 cutoffs (0.05, 0.15, 0.25, 0.35) and set the plot argument to **TRUE**.

The output in this case contains two **Graphs** which show the adaptation value (alpha) and the negative selection fractions obtained using each cutoff.

&nbsp;

```{r, echo=TRUE, fig.width=6, fig.height=6}
DGRP(daf=mydafdata, divergence=mydivergencedata, list_cutoff=c(0.05, 0.15,0.25,0.35), plot=TRUE)
```

&nbsp;

### Asymptotic MKT
Petrov reference + explanation

&nbsp;

```{r Asymptotic MKT, echo=TRUE}
asymptoticMK(daf=mydafdata, divergence=mydivergencedata, xlow=0, xhigh=0.9)
```

&nbsp;

### iMK
Asymptotic explanation + Sergi slightly deleterious approach

&nbsp;

```{r iMK, echo=TRUE, fig.width=6, fig.height=9}
iMK(daf=mydafdata, divergence=mydivergencedata, xlow=0, xhigh=0.9, plot=TRUE)
```

&nbsp;


### Miscelanious

The **multipleDatasets()** function allows performing any MK test using all files (or a subset of them) in a given directory. Files in directory must be named: file1.**daf**, file1.**divergence**, file2.*daf*, file2.**divergence**, ..., where file corresponds to the samples of interest.

<!-- If you have a bunch of data like the following, or simply have several genes datasets: -->
<!-- <!-- ![alt text](~/Pictures/test.png) -->
<!-- Maybe you want to perform some test or compare the test results between your datasets. You could execute the funtion multipleDatasets, putting your datasets in a directory a name them with the extensions **ID.daf.txt**/**ID.divergence.txt**. Then execute the following commands to perform the tests: -->

<!-- &nbsp; -->

<!-- ```{r multipleDatasets, eval=FALSE, include=FALSE} -->
<!-- # multipleDatasets(directory = directory, test = c("standard", "DGRP", "FWW","asymptotic", "iMK"), xlow = 0, xhigh = 1, fullAnalysis = TRUE/FALSE,idList = "NA") -->
<!-- ``` -->

<!-- &nbsp; -->
<!-- &nbsp; -->

<!-- The idList argument allow to the user pass a plain text file with the IDs, in the case you want to subset the analysis to just a few datasets. It is used when fullAnalysis = FALSE, list of IDs to analyze -->

